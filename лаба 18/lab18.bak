#lang scheme
; задача 1
(define (quick-sort lst)
  (define (iter lst center lower middle upper)
    (if (null? lst) (append (quick-sort lower) middle (quick-sort upper))
        (if (< (car lst) center)
            (iter (cdr lst) center (cons (car lst) lower) middle upper)
            (if (> (car lst) center)
                (iter (cdr lst) center lower middle (cons (car lst) upper))
                (iter (cdr lst) center lower (cons (car lst) middle) upper)
            )
        )
    )
  )
  (if (null? lst) lst
      (iter lst (car lst) '() '() '())
  )
)
(define (task2 lst)
   (define (sum-d a sum)
      (if (= 0 a) sum
          (sum-d (quotient a 10) (+ sum (remainder a 10)))
      )
    )
  (define (insert n lst)
    (if (or (null? lst) (>= (sum-d (abs n) 0) (sum-d (abs (car lst)) 0)))
        (cons n lst)
        (cons (car lst) (insert n (cdr lst)))
    )
  )
  (foldl insert '() lst)
)

(define (task3 In Out)
    (define in (open-input-file In))
    (define out (open-output-file Out #:exists 'replace))
    (define (wrote num was)
        (if was
            (begin
                (write num out)
                (newline out)
            )
            #f
        ))
    (define (iter num was sum k)
        (define ch (read-char in))
        (if (equal? ch eof)
            (begin
                (wrote num was)
                (newline out)
                (write (+ (if was num 0) sum) out)
                (newline out)
                (write  (+ (if was 1 0) k) out)
                (close-output-port out)
            )
            (if (<= 48 [char->integer ch] 57)
                (iter (+ [char->integer ch] -48 (* 10 num)) #t sum k)
                (begin
                    (wrote num was)
                    (if was
                        (iter 0 #f (+ num sum) (+ 1 k))
                        (iter 0 #f sum k)
                    )
                )
            )
        )
        
    )
    (iter 0 #f 0 0)
)

(define (di w d)
        (if (null? d) (error "di w error")
            (if (equal? w (caar d))
                (cdar d)
                (di w (cdr d))
            )
        )
    )

(define (wrote lst out)
  (if (null? lst) (void)
      (begin
        (write-char (car lst) out)
        (wrote (cdr lst) out)
      )
  )
)

(define (task5 In Out Dict)
    (define in (open-input-file In))
    (define out (open-output-file Out #:exists 'replace))
    (define dict (open-input-file Dict))
    ; 1) make dictionary
    (define (updres k w res)
        (cons
            (cons k (reverse w))
            res
        )
    )
    (define (iter-dict k w mode res)
        (define ch (read-char dict))
        
        (if (equal? ch eof)
            (updres k w res)
            (if mode
                (if (equal? ch #\return)
                    (begin
                        (read-char dict)
                        (iter-dict '() '() #f (updres k w res))
                    )
                    (iter-dict k (cons ch w) mode res)
                )
                (if (equal? ch #\space)
                    (iter-dict k w #t res)
                    (iter-dict (cons ch k) w #f res)
                )
            )
        )
    )
    (define D (iter-dict '() '() #f '()))
    
    (define (iter w was)
        (define ch (read-char in))
        (if (equal? ch eof)
            (wrote (di w D) out)
            (if (or (equal? ch #\space) (equal? ch #\return) (equal? ch #\tab))
                (begin
                  (when was (wrote (di w D) out))
                  (when (equal? ch #\space)
                      (display " " out))
                  (when (equal? ch #\tab)
                    (display "	" out))
                  (when (equal? ch #\return) (begin (newline out) (read-char in)))
                  (iter '() #f)
                )
                (iter (cons ch w) #t)
                    
            )
        )
    )
    (iter '() #f)
    (close-output-port out)
)